<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clear DNA Helix - Pastel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; }
        canvas { display: block; }
    </style>
</head>
<body>

    <div class="fixed inset-0 z-20 pointer-events-none flex flex-col justify-end p-12 md:p-24">
    <div class="fixed inset-0 z-20 pointer-events-none flex flex-col justify-end p-12 md:p-24">
        <div class="max-w-md pointer-events-auto">
            <h1 class="text-5xl font-thin tracking-tighter text-slate-800 mb-2">
                
            </h1>
            <div class="flex gap-4 items-center">
                <span class="h-[1px] w-12 bg-pink-200"></span>
                <p class="text-slate-400 text-xs tracking-[0.2em] uppercase font-medium">
                
                </p>
            </div>
        </div>
    </div>


    <div id="scene-container" class="fixed inset-0 z-0"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const container = document.getElementById('scene-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(0, 0, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Clear, Bright Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambient);
        const directional = new THREE.DirectionalLight(0xffffff, 1);
        directional.position.set(5, 10, 7);
        scene.add(directional);

        const dnaGroup = new THREE.Group();
        dnaGroup.position.x = 2; 
        scene.add(dnaGroup);

        // Precise Color Palette
        const matPink = new THREE.MeshPhysicalMaterial({ 
            color: 0xFFD1DC, 
            emissive: 0xFFD1DC,
            emissiveIntensity: 0.2,
            roughness: 0.3,
            metalness: 0
        });
        const matBlue = new THREE.MeshPhysicalMaterial({ 
            color: 0xB9E2FF, 
            emissive: 0xB9E2FF,
            emissiveIntensity: 0.2,
            roughness: 0.3,
            metalness: 0
        });
        const matWhite = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

        // Geometry with higher detail
        const sphereGeo = new THREE.SphereGeometry(0.2, 32, 32);
        const rungGeo = new THREE.CylinderGeometry(0.04, 0.04, 2.2, 16);
        rungGeo.rotateZ(Math.PI / 2);

        const levels = 40;
        const spacing = 0.32;
        const twist = 0.38;
        const radius = 1.1;

        // Arrays to store positions for the backbone lines
        const points1 = [];
        const points2 = [];

        for (let i = 0; i < levels; i++) {
            const y = (i - levels / 2) * spacing;
            const angle = i * twist;

            // Strand 1
            const pos1 = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
            const s1 = new THREE.Mesh(sphereGeo, matPink);
            s1.position.copy(pos1);
            dnaGroup.add(s1);
            points1.push(pos1);

            // Strand 2
            const angle2 = angle + Math.PI;
            const pos2 = new THREE.Vector3(Math.cos(angle2) * radius, y, Math.sin(angle2) * radius);
            const s2 = new THREE.Mesh(sphereGeo, matBlue);
            s2.position.copy(pos2);
            dnaGroup.add(s2);
            points2.push(pos2);

            // Rungs
            if (i % 2 === 0) {
                const rung = new THREE.Mesh(rungGeo, matWhite);
                rung.position.y = y;
                rung.rotation.y = -angle;
                dnaGroup.add(rung);
            }
        }

        // Creating smooth Backbone lines
        const curve1 = new THREE.CatmullRomCurve3(points1);
        const tubeGeo1 = new THREE.TubeGeometry(curve1, 64, 0.03, 8, false);
        dnaGroup.add(new THREE.Mesh(tubeGeo1, matPink));

        const curve2 = new THREE.CatmullRomCurve3(points2);
        const tubeGeo2 = new THREE.TubeGeometry(curve2, 64, 0.03, 8, false);
        dnaGroup.add(new THREE.Mesh(tubeGeo2, matBlue));

        function animate() {
            requestAnimationFrame(animate);
            dnaGroup.rotation.y += 0.007;
            dnaGroup.rotation.z = Math.sin(Date.now() * 0.0005) * 0.05;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const a = window.innerWidth / window.innerHeight;
            camera.left = -d * a; camera.right = d * a;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
